<!DOCTYPE html>
<html lang="en">

<head>
	<title>THREE - SNAKE</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		html,
		body {
			width: 100%;
			height: 100%;
		}

		body {
			background-color: #ffffff;
			margin: 0;
			overflow: hidden;
			font-family: arial;
		}

		#blocker {
			position: absolute;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.5);
		}

		#instructions {
			width: 100%;
			height: 100%;
			display: -webkit-box;
			display: -moz-box;
			display: box;
			-webkit-box-orient: horizontal;
			-moz-box-orient: horizontal;
			box-orient: horizontal;
			-webkit-box-pack: center;
			-moz-box-pack: center;
			box-pack: center;
			-webkit-box-align: center;
			-moz-box-align: center;
			box-align: center;
			color: #ffffff;
			text-align: center;
			cursor: pointer;
		}
		#textOne{
			font-size: 3em;
		}
		#textTwo{
			font-size: 1.5em;
		}
		#scoreboard{
			font-size: 5em;
			font-family: sans-serif;
			padding: 4%;
			width: 100px;
			height: 100px;
			/* text-align: center; */
			position: fixed;
			top: 0;
			left: 0;
			z-index: 5;
		}
		a, a:link{
			color: #33ccff;
			text-decoration: none;
		}
		a:hover{
			color: #e6f9ff;
		}
		a:visited{
			color: #33ccff;
		}
		a:active{
			color: #33ccff;
		}
	</style>
</head>

<body>
	<script src="/three-snake/node_modules/three/build/three.js"></script>
	<script src="/three-snake/node_modules/three/examples/js/controls/PointerLockControls.js"></script>
	<script src="/three-snake/node_modules/three/examples/js/libs/tween.min.js"></script>
	<div id="scoreboard">
		<span id="score"></span>
	</div>
	<div id="blocker">
		<div id="instructions">
			<span id="textOne">Click to play</span><br />
			<span id="textTwo">Don't run into your tail, eat as many dots as you can!</span>
		</div>
	</div>

	<script>
		var element = document.body;
		var blocker = document.getElementById('blocker');
		var instructions = document.getElementById('instructions');
		var textOne = document.getElementById('textOne');
		var textTwo = document.getElementById('textTwo');
		var score = document.getElementById('score');

		var animationFrame;
		var camera, scene, renderer, controls;
		var dotContainer = [],
			dot, dotGeometry;

		// http://www.html5rocks.com/en/tutorials/pointerlock/intro/

		var controlsEnabled = false;
		var moveForward = true;
		var moveBackward = false;
		var moveLeft = false;
		var moveRight = false;
		var moveUp = true;
		var moveDown = false;
		// var canJump = false;
		var startTime, prevTime;
		var velocity = new THREE.Vector3(0,0,0);
		var direction = new THREE.Vector3();
		var raycaster, objectDetect;
		var center = new THREE.Vector2(0, 0);
		var INTERSECTED, MAX_SPEED = 3000;

		var snake, bodyPartSize = 20,
			bodyParts = [],
			snakePrevPos;
		var boundary, boxGeometry, floor,
			corners = [],
			points = 0,
			speed = 400.0;
		var parent, bodyGeometry, bodyMaterial, consumeDot = false;
		var eatDotPosition = new THREE.Vector3(),
			currentGlobalPos = new THREE.Vector3();

		var body = {
			snake: [{
				part: "head",
				positions: [
					new THREE.Vector3(0,0,0),
					new THREE.Vector3(0,0,0),
					new THREE.Vector3(0,0,0),
					new THREE.Vector3(0,0,0),
					new THREE.Vector3(0,0,0)
				],
				rotations: []
			}]
		};

		var havePointerLock = 'pointerLockElement' in document ||
													'mozPointerLockElement' in document ||
													'webkitPointerLockElement' in document;

		if ( havePointerLock ) {
			var pointerlockchange = function ( event ) {
				if ( 	document.pointerLockElement === element ||
							document.mozPointerLockElement === element ||
							document.webkitPointerLockElement === element ) {

					controlsEnabled = true;
					controls.enabled = true;
					blocker.style.display = 'none';
				} else {

					controls.enabled = false;
					blocker.style.display = 'block';
					instructions.style.display = '';
				}
			};

			var pointerlockerror = function ( event ) {
				instructions.style.display = '';
			};

			// Hook pointer lock state change events
			document.addEventListener( 'pointerlockchange', pointerlockchange, false );
			document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
			document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

			document.addEventListener( 'pointerlockerror', pointerlockerror, false );
			document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
			document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

			instructions.addEventListener( 'click', function ( event ) {
				console.log(`Instructions clicked`);
					blocker.style.display = 'none';
					controlsEnabled = true;
					controls.enabled = true;
				// Ask the browser to lock the pointer
				element.requestPointerLock = 	element.requestPointerLock ||
																			element.mozRequestPointerLock ||
																			element.webkitRequestPointerLock;
				element.requestPointerLock();

			}, false );
		} else {
			instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
		}

		init();
		animate();


		function init() {
			startTime = performance.now();
			prevTime = performance.now();

			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2000);
			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xffffff);
			scene.fog = new THREE.Fog(0xffffff, 0, 750);
			var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
			light.position.set(0.5, 1, 0.75);
			scene.add(light);

			// floor
			var floorGeometry = new THREE.PlaneGeometry(500, 500, 10, 10);
			floorGeometry.rotateX(-Math.PI / 2);
			var floorMaterial = new THREE.MeshBasicMaterial({
				color: 0x800000
			});
			floor = new THREE.Mesh(floorGeometry, floorMaterial);
			scene.add(floor);

			//boundary
			boxGeometry = new THREE.BoxGeometry(500, 500, 500, 10, 10, 10);
			boundary = new THREE.Mesh(boxGeometry, new THREE.MeshBasicMaterial({
				color: 0x65d9ee,
				wireframe: true
			}));
			boundary.position.set(0, 250, 0);
			scene.add(boundary);
			corners = findCorners(boundary);

			//character
			controls = new THREE.PointerLockControls(camera);
			snake = controls.getObject();
			snake.position.set(0, 10, 250);
			scene.add(snake);
			parent = snake;
			snakePrevPos = new THREE.Vector3();
			snake.getWorldPosition(snakePrevPos);

			bodyParts.push(snake);

			//build for snake body parts
			bodyGeometry = new THREE.SphereGeometry(bodyPartSize / 2, 32, 32);
			bodyMaterial = new THREE.MeshNormalMaterial();


			raycaster = new THREE.Raycaster();


			// dot objects
			dotGeometry = new THREE.SphereGeometry(bodyPartSize / 2, 32, 32);
			dot = new THREE.Mesh(dotGeometry, new THREE.MeshLambertMaterial({
				color: "rgb(255, 255, 255)"
			}));
			dot.position.set(0, 10, 0);
			dot.name = 'dot';
			dotContainer.push(dot);
			scene.add(dot);

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			window.addEventListener('keydown', onKeyDown, false);
			window.addEventListener('resize', onWindowResize, false);
			console.log(`Game Loaded`);
		} //END INIT


		function animate() {
			animationFrame = requestAnimationFrame(animate);
			render();
		} //END ANIMATE

		function render() {
			TWEEN.update();
			trackPositionMovement();

			raycaster.setFromCamera(center.normalize(), camera);
			let intersects = raycaster.intersectObjects(scene.children);
			if (intersects.length > 0) {
				let cameraPos = new THREE.Vector3();
				cameraPos.setFromMatrixPosition(camera.matrixWorld);
				let distance = distanceVector(cameraPos, intersects[0].object.position);

				if (intersects[0].object.name == 'dot'){
					console.log('dot detected');

					//CONSUMES DOTS
					if (distance < 12) {
						snake.getWorldPosition(eatDotPosition);

						consumeDot = true;
						removeEntity(intersects[0].object);
						addEntity(dot);

						if (speed < MAX_SPEED){
							speed *= 1.1;
						}

						buildBody();

						points++;
						score.innerHTML = points;
						// console.log(`points: ${points}`);
					}

					if (INTERSECTED != intersects[0].object) {

						if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);

						INTERSECTED = intersects[0].object;
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex(0xff0000);

					}
				} else if (intersects[0].object.name == 'bodyPart'){

					if (distance < 12) {
						console.log(`bodyParts detected`);
						endGame();
					}
				}

			} else {

				if (INTERSECTED) INTERSECTED.material.emissive.setHex(INTERSECTED.currentHex);

				INTERSECTED = null;

			}

			let time = performance.now();

			let delta = (time - prevTime) / 1000;
			velocity.x -= velocity.x * 10.0 * delta;
			velocity.z -= velocity.z * 10.0 * delta;
			velocity.y -= velocity.y * 10.0 * delta;

			// velocity.y -= 9.8 /** 100.0*/ * delta; // 100.0 = mass
			direction.z = Number(moveForward) - Number(moveBackward);
			// direction.x = Number( moveLeft ) - Number( moveRight );
			// direction.y = Number( moveUp ) - Number( moveDown );

			direction.normalize(); // this ensures consistent movements in all directions
			if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
			// if ( moveLeft || moveRight ) {
			// 	velocity.x -= direction.x * 400.0 * delta;
			// }

			controls.getObject().translateX(velocity.x * delta);
			controls.getObject().translateY(velocity.y * delta);
			controls.getObject().translateZ(velocity.z * delta);


			renderer.render(scene, camera);

			prevTime = time;

		} //END RENDER



		function trackPositionMovement() {

			snake.getWorldPosition(currentGlobalPos);
			// console.log(`trackPositionMovement: ${currentGlobalPos.x}, ${currentGlobalPos.y}, ${currentGlobalPos.z}`);
			// console.log(`trackPositionMovement snakePrevPos: ${snakePrevPos.x}, ${snakePrevPos.y}, ${snakePrevPos.z}`);
			// console.log(`trackPositionMovement currentGlobalPos: ${currentGlobalPos.x}, ${currentGlobalPos.y}, ${currentGlobalPos.z}`);
			let distance = distanceVector(snakePrevPos, currentGlobalPos);
			// console.log(`trackPositionMovement distance: ${distance}`);


			// var matrix = new THREE.Matrix4();
			// matrix.extractRotation( mesh.matrix );

			// var direction = new THREE.Vector3( 0, 0, 1 );
			// direction = matrix.multiplyVector3( direction );

			if (distance > bodyPartSize / 2) {

				//update position tracking values for head of snake
				body.snake[0].positions.unshift(new THREE.Vector3(
					currentGlobalPos.x,
					currentGlobalPos.y,
					currentGlobalPos.z));

				if (body.snake[0].positions.length > 5) {
					body.snake[0].positions.pop();
				}

				//update all position tracking values for each body part
				for (let i = 0; i < bodyParts.length - 1; i++) {
					body.snake[i + 1].positions.unshift(body.snake[i].positions[2]);

					// console.log(`body.snake[i + 1].positions: ${body.snake[i + 1].positions[0].x}, ${body.snake[i + 1].positions[0].y}, ${body.snake[i + 1].positions[0].z}`);
					if (body.snake[i + 1].positions.length > 5) {
						body.snake[i + 1].positions.pop();
					}

					//animate movement to new position
					// console.log(`moving bodyParts[${i+1}] to: ${body.snake[i + 1].positions[0].x}, ${body.snake[i + 1].positions[0].y}, ${body.snake[i + 1].positions[0].z}`);
					let object = bodyParts[i+1];

					// console.log(`bodyParts[${i+1}] positions: ${body.snake[i+1].positions[0].z}, ${body.snake[i+1].positions[1].x}, ${body.snake[i+1].positions[2].x}, ${body.snake[i+1].positions[3].x}, ${body.snake[i+1].positions[4].x} `);

					new TWEEN.Tween(object.position).to({
						x: body.snake[i+1].positions[0].x,
						y: body.snake[i+1].positions[0].y,
						z: body.snake[i+1].positions[0].z
					}, 250).easing(TWEEN.Easing.Linear.None).start();

				}

				// new TWEEN.Tween(bodyParts[0].rotation).to({
				// 	x: body.snake[1].positions[0].x,
				// 	y: body.snake[1].positions[0].y,
				// 	z: body.snake[1].positions[0].z
				// }, 150).start();

				snakePrevPos.set(currentGlobalPos.x, currentGlobalPos.y, currentGlobalPos.z);
			}
		} //END trackPositionMovement()

		function buildBody() {

			body.snake.push({
				part: "body",
				positions: [],
				rotations: []
			});

			// console.log(`body.snake.length: ${body.snake.length}`);

			let prevBodyPartPosition = body.snake[(bodyParts.length - 1)].positions[0];
			// console.log(`prevBodyPartPosition: ${body.snake[(bodyParts.length - 1)].positions[1].x}, ${body.snake[(bodyParts.length - 1)].positions[1].y}, ${body.snake[(bodyParts.length - 1)].positions[1].z}`);

			let bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);

			// console.log(`body.snake[${bodyParts.length}].positions.length: ${body.snake[bodyParts.length].positions.length}`);

			bodyMesh.position.set(
				prevBodyPartPosition.x,
				prevBodyPartPosition.y,
				prevBodyPartPosition.z + bodyPartSize + bodyPartSize / 2
			);

			bodyMesh.name = 'bodyPart';

			// console.log(`bodyMesh.position: ${bodyMesh.position.x}, ${bodyMesh.position.y}, ${bodyMesh.position.z}`);
			bodyParts.push(bodyMesh);
			scene.add(bodyMesh);
			// console.log(`Body length: ${bodyParts.length}`);
		}

		function addEntity(object) {
			let c1 = corners[6],
				c2 = corners[7],
				c3 = corners[2],
				c4 = corners[3];
			//-250, 250, 250, -250
			// console.log(`addEntity: ${c1.x}, ${c3.x}, ${c1.z}, ${c2.z}`);
			let x = Math.floor(Math.random() * (250 - bodyPartSize/2)) + 1; // this will get a number between 1 and 240;
			x *= Math.floor(Math.random() * 2) == 1 ? 1 : -1;
			let z = Math.floor(Math.random() * (250 - bodyPartSize/2)) + 1; // this will get a number between 1 and 240;
			z *= Math.floor(Math.random() * 2) == 1 ? 1 : -1;
			// let x =	Math.floor(Math.random() * c3.x) - c1.x;
			// let y = Math.floor(Math.random());
			// let z =	Math.floor(Math.random() * c2.z) - c1.z;
			// console.log(`in addEntity: ${x}, ${z}`);


			object.position.set(x, 10, z); // on flat plane temporarily
			scene.add(object);
		}

		function findCorners(object) {
			let width = object.geometry.parameters.width;
			let height = object.geometry.parameters.height;
			let depth = object.geometry.parameters.depth;

			let corners = [];
			let c = [];
			corners.push(new THREE.Vector3(object.position.x + width / 2, object.position.y + height / 2, object.position.z + depth / 2));
			corners.push(new THREE.Vector3(object.position.x + width / 2, object.position.y + height / 2, object.position.z - depth / 2));
			corners.push(new THREE.Vector3(object.position.x + width / 2, object.position.y - height / 2, object.position.z + depth / 2));
			corners.push(new THREE.Vector3(object.position.x + width / 2, object.position.y - height / 2, object.position.z - depth / 2));
			corners.push(new THREE.Vector3(object.position.x - width / 2, object.position.y + height / 2, object.position.z + depth / 2));
			corners.push(new THREE.Vector3(object.position.x - width / 2, object.position.y + height / 2, object.position.z - depth / 2));
			corners.push(new THREE.Vector3(object.position.x - width / 2, object.position.y - height / 2, object.position.z + depth / 2));
			corners.push(new THREE.Vector3(object.position.x - width / 2, object.position.y - height / 2, object.position.z - depth / 2));

			// console.log(`corners in findCorners: ${corners[1].x}, ${corners[1].y}, ${corners[1].z}`);
			for (let i = 0; i < corners.length; i++) {
				c.push(new THREE.Mesh(new THREE.SphereGeometry(10, 32, 32), new THREE.MeshLambertMaterial({
					color: 0xffff00
				})));
				c[i].position.set(corners[i].x, corners[i].y, corners[i].z);
				scene.add(c[i]);
			}
			return corners;
		}

		function removeEntity(object) {
			let selectedObject = scene.getObjectById(object.id);
			scene.remove(selectedObject);
		}

		function distanceVector(v1, v2) {

			var dx = v1.x - v2.x;
			var dy = v1.y - v2.y;
			var dz = v1.z - v2.z;

			return Math.sqrt(dx * dx + dy * dy + dz * dz);
		}

		function endGame(){
			cancelAnimationFrame(animationFrame);
			blocker.style.display = 'block';
			textOne.innerHTML = 'Game Over';
			textTwo.innerHTML = 'Click <a href="index.html">here</a> to play again';
			controlsEnabled = false;
			controls.enabled = false;
			document.exitPointerLock();
		}

		function onKeyDown(event) {
			console.log(`Key: ${event.keyCode}`);
			// if (event.keyCode == 87) { //w
				// controls.getObject().position.setY( velocity.y * 2 );
			// } else if (event.keyCode == 83) {
				// controls.getObject().translateY( -velocity.y * 1 );
			// }
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}
	</script>
</body>

</html>
